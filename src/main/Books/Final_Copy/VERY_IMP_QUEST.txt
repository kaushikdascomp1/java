 ###########################Hash Map############################
>>public native int hashCode();   Hash function
>>hashCode method return  int value >> Hash Value
>>What is bucket ?
A bucket is used to store key value pairs . 
A bucket can have multiple key-value pairs . 
In hash map, bucket used simple linked list to store objects .
Bucket : where keys and values are stored in form of a nested class called Entry (Map.Entry) .

Public Object get(String key){
 if(key == null){ 
 take the value from 0th index of bucket.  If key is null , then Null keys always map to hash 0, thus index 0.
 }
 int hash = hash(key.hashCode())   // Finding bucket location (backing array)and defend aginst poor quality of hash no.
 // if key found in hash table then  return value
 //    else return null
}

Entry Object :  store in bucket like this (hash,key,value,bucketindex) .

Q.What if  when two different keys have the same hashcode ? then equal method come in picture.
So we traverse through linked list , comparing keys in each entries using keys.equals() until it return true.
  Then the corresponding entry object Value is returned .
  
  
Q.  When the functions 'equals' traverses through the linked list does it traverses from start to end one by one.
  in other words brute method. Or the linked list is sorted based on key and then it traverses? 
  
 indexFor(int,int) method  returns the first entry in the appropriate bucket. The linked list in the bucket is then iterated over - 
 (the end is found and the element is added or the key is matched and the value is returned )
 
 static int indexFor(int h, int length) {
    return h & (length-1);
}

Q Measuere Preformance of Hash map?

 initial capacity and load factor. 
 The capacity is the number of buckets in the hash table
 
 Load factor of HashMap :
 
 Load Factor is a measure which defines how much HashMap should be full before the capacity of HashMap is automatically increased.
 
 It will be determined based on the product of  initialCapcity and loadfactor (16*0.75)=12 Mean After 12 the Key Value pair we are trying to insert new Key value pair
 mean 13 enty then capcity of Hash Map automatically getting increased by 16*2=32.
 complexity of get() and put() is O(1) 
 
 #########################################
 
prior to JDK1.5 only two collection are the which are thread safe: Hashtable and synchronized Map prior to JDK 5.


Q.. Why we need ConcurrentHashMap when we already had Hashtable  , synchronized Map?

Hashtable provides concurrent access to the Map.Entries objects by locking the entire map to perform any sort of operation (update,delete,read,create).	
Overhead >> Created by hashtable we can ignored in under normal load. but In havy load may be lead to delay response time and overtaxing of the server.

To recuse this prob ConcurrentHashMap comes....
 
ConcurrentHashMap Working (jdk1.5)...
Used in  multi-threaded application and hence it does not require explicit synchronization....
Main perpous of this class is >>>> Provide the same funallity for thread safty as per Hashtable but with a performance comparable to HashMap. 

***public ConcurrentHashMap (int initialCapacity, float loadFactor, int concurrencyLevel)***
>>  internal sizing to accommodate this many elements.
>>  concurrencyLevel - the estimated number of concurrently updating threads.


static final int DEFAULT_INITIAL_CAPACITY = 16;
static final int DEFAULT_CONCURRENCY_LEVEL = 16;


Functionllity of ConcurrentHashMap:::::
>> ConcurrentHashMap maintains  a list of 16 locks by default  (based on it's concurrency level.....)
>> ( number of locks equal to the initial capacity , which is by default  16).
>> each of thread is used to lock on a single bucket of the Map.
>> This indicates that 16 threads (number of threads equal to the concurrency level , which is by  default 16) can modify the collection at the same time , 
given ,each thread works on different bucket.
>> So unlike hashtable, we perform any sort of operation ( update ,delete ,read ,create) without locking on entire map in ConcurrentHashMap.

Q..Interviewer : Can two threads update the ConcurrentHashMap simultaneously ?                                            
Yes it is possible that two threads can simultaneously write on the ConcurrentHashMap. ConcurrentHashMap default implementation allows 16 threads to read 
and write in parallel.But in the worst case scenario , when two objects lie in the same segment or same partition, then parallel write would not be possible.

Q..Interviewer : Why does ConcurrentHashMap does not allow null keys and null values ?

1) we can syncronize null value
2) if (m.containsKey(k)) {
   return m.get(k);
} else {
   throw new KeyNotPresentException();
}
It might be possible that key k might be deleted in between the get(k) and containsKey(k) calls. As a result , the code will return null as opposed to KeyNotPresentException (Expected Result if key is not present). 

3)The main reason that nulls aren't allowed in ConcurrentMaps is ambiguities that may be just barely tolerable in non-concurrent maps can't be accommodated.
The main one is that if map.get(key) returns null, you can't detect whether the key explicitly maps to null vs the key isn't mapped. In a non-concurrent map, you can check this via  map.contains(key), but in a concurrent one, the map might have changed between calls. 

Q. Interviewer: Does ConcurrentHashMap Iterator behaves like fail fast iterator or fail safe Iterator? 
ConcurrentHashMap iterator behaves like fail safe iterator. It will not throw ConcurrentModificationException .

-------------------------------------------------------------------------------
Q. HashMap vs ConcurrentHashMap
#######################################
1.  Thread -Safe :   ConcurrentHashMap is thread-safe that is the code can be accessed by single thread at a time .while HashMap is not thread-safe .
2.  Synchronization Method : HashMap can be synchronized by using synchronizedMap(HashMap)  method .  By using this  method we get a HashMap object which 
	is equivalent to the HashTable object . So every modification  is performed on  Map is locked on Map object.(Collections.synchronizedMap(map);)
	
	ConcurrentHashMap synchronizes or locks on the certain portion of the Map . To optimize
   the performance of ConcurrentHashMap , Map is divided into different partitions depending
   upon the Concurrency level . So that we do not need to synchronize the whole Map Object.
   
3.  Null Key : ConcurrentHashMap does not allow NULL values . So the key can not be null in
			   ConcurrentHashMap .While In HashMap there can only be one null key .
			   
4.  Performance : In multiple threaded environment HashMap is usually faster than ConcurrentHashMap .
	As only single thread can access the certain portion of the Map and thus reducing the performance . 
     While in HashMap any number of threads can access the code at the same time .
	 
######################################################################
Difference between Fail Fast iterator and Fail Safe iterator
##################################################################
FailFast: Fail fast iterator while iterating through the collection , instantly throws Concurrent Modification Exception if there is structural modification 
 of the collection .Thus, in the face of concurrent modification, the iterator fails quickly.

Fail-fast iterator can throw ConcurrentModificationException in two scenarios :
Single Threaded Environment: After the creation of the iterator , structure is modified at any time by any method other than iterator's own remove method. 
Multiple Threaded Environment :  If one thread is modifying the structure of the collection while other thread is iterating over it .

The fail-fast behavior of an iterator cannot be guaranteed in the presence of unsynchronized collection objects.
Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. 
 Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used
 only to detect bugs. 
 Q..Interviewer : How  Fail  Fast Iterator  come to know that the internal structure is modified ?
	Iterator read internal data structure (object array) directly . The internal data structure(i.e object array) should not be modified while iterating 
	through the collection. To ensure this it maintains an internal  flag "mods" .Iterator checks the "mods" flag whenever it gets the next value
	using hasNext() method and next() method). Value of mods flag changes whenever there is an structural modification. Thus indicating iterator to throw
	ConcurrentModificationException.
Fail fast : HashMap,Vector,ArrayList,HashSet
	
Fail Safe Iterator :
Fail Safe Iterator makes copy of the internal data structure (object array) and iterates over the copied data structure.Any structural modification done to 
the iterator affects the copied data structure.  So , original data structure remains  structurally unchanged .Hence , 
no ConcurrentModificationException throws by the fail safe iterator.	

Two  issues associated with Fail Safe Iterator are :
Memory Overhead : 1. Overhead of maintaining the copied data structure i.e memory.
Not guarnatee : 2.  Fail safe iterator does not guarantee that the data being read is the data currently in the original data structure. 
Faild safe ex : CopyOnWriteArrayList,ConcurrentHashMap

##########################################################################
Array List and Vector
#########################################################################
1.  Synchronization and Thread-Safe: Vector is  synchronized while ArrayList is not synchronized.
Synchronization and thread safe means at a time only one thread can access the code .In Vector class all the methods are synchronized .Thats why the Vector object is already synchronized when 
it is created .

2.  Performance: Vector is slow as it is thread safe . In comparison ArrayList is fast 
ArrayList two or more threads  can access the code at the same time  , while Vector is limited to one thread at a time.

3. Automatic Increase in Capacity: A Vector defaults to doubling size of its array .While when you insert an element into the ArrayList , it increases
its Array size by 50%  . By default ArrayList size is 10 . It checks whether it reaches the  last  element then it will create the new array ,copy the new data of last array to new array ,then old array     
is garbage collected by the Java Virtual Machine (JVM) . 

4. Set Increment Size : ArrayList does not define the increment size . Vector defines the increment size .
public synchronized void setSize(int i) { //some code  }
There is no setSize() method or any other method in ArrayList which can manually set the increment size.

5. Enumerator : Other than Hashtable ,Vector is the only other class which uses both Enumeration and Iterator .
While ArrayList can only use Iterator for traversing an ArrayList .

6. Introduction in Java : java.util.Vector  class was there in java since the very first version of the java development kit (jdk).
java.util.ArrayList  was introduced in java version 1.2 , as part of Java Collections framework . In java version 1.2 , 
Vector class has been refactored to implement the List Inteface .

##########################################
Differeance B/W ArrayList and LinkedList
##########################################
Similiearity:
1) Both ArrayList and LinkedList are implementation of List interface.  which means you can pass either ArrayList or LinkedList if a method accepts List interface.
2) Both ArrayList and LinkedList are not synchronized  which means you can not shared them between multiple threads without external synchronization.
3) ArrayList and LinkedList are ordered collection  they maintain insertion order of elements i.e. first element will be added on first position.
4) ArrayList and LinkedList also allows duplicates and null unlike any other List implementation
5) Iterator of both LinkedList and ArrayList are fail-fast which means they will throw ConcurrentModificationException if collection is modified 
structurally once Iterator is created. They  are different than CopyOnWriteArrayList whose Iterator is fail-safe.

------Differeance B/W ArrayList and LinkedList-------
Data Structure:
1)First difference between ArrayList Internally using dynamic array where as LinkedList is using linked list.

Implementation: 
2) LinkedList implements List as well as Deque where as ArrayList implements List Interface.
3) LinkedList providing FIFO operation for add() and poll() and Deque functions and also implements doubly linked list where as arrylist is not.

Retiving element in ArrayList(get method retrival)
4)Getting element from Array with index is pretty fast because Array provides O(1) performance for get(index) method.
  Retriving the element is constly in case of linked list because it has to travesed or you need to iterate over linked list so it givs o(n).	

Inserting element from a position:
5)Instring element in case of Linked list is fast and it give o(1). But ArrayList gives o(1) in bast case when trying to insert element in last index. but it we trying to add element othere then
last array list has to shif the elements so it will give o(n).

Removal:
6)Removal like insertion.

Memory Overhead
7) LinkedList has more memory overhead than ArrayList because in ArrayList each index only holds actual object (data) but in case of LinkedList 
each node holds both data and address of next  and previous node.
##########################################################################
Java out of memory error

1) Java.lang.OutOfMemoryError: Java heap space
2) Java.lang.OutOfMemoryError: PermGen space
##########################################################################
1) OutOfMemoryError in Java is a subclass of java.lang.VirtualMachineError and JVM throws java.lang.OutOfMemoryError when it ran out of memory in heap.



######################################################################
HOW GC Works.......................in java
######################################################################
Algo used by GC >>>  Mark and Sweep

Since JVM provides memory management , Java developers only care about creating object, they don't care about cleaning up
Garbage Collection in Java is carried by a daemon thread called Garbage Collector
Before removing an object from memory garbage collection thread invokes finalize() method of that object and gives an opportunity to perform any sort of cleanup required.
You as Java programmer can not force garbage collection in Java; it will only trigger if JVM thinks it needs a garbage collection based on Java heap size.
There are methods like System.gc() and Runtime.gc() which is used to send request of Garbage collection to JVM but it’s not guaranteed that garbage collection will happen.

Mark n Sweep how it works:>>>>>>
When any obj which has no live strong reference or it's not reachable from any thread then object will become abendend.

1) When any object become abendend then it is elegible for GC. the how GC knows only these many objects are abended?
Firt GC Figur out the how many no of active threads are present and then it will traverse through each thread and then GC will MARK those objects which is not abendend mean 
those are not refreanced as null.
2)Now GC will Mark all the object which is no refrenced as null and after markin it will rum SWEEP Alog to clean the heap memory it will clean only those object with are not marked.


There are different kinds of garbage collector available in Java to collect different area of heap  memory >>>>
-Single
-parallel 
-concurrent
-G1 (Garbage first) -> jdk1.7



####################################################################
Memory Leak in java...........how we figur out in java
###################################################################
Ans: 

####################################################################
Java Class Loaders : In bref
###################################################################
Ans : Java class loaders are used to load classes at runtime.
ClassLoader in Java works on three principle: 
1) Delegation : 
2) visibility 
3) uniqueness

####################################################################
Differance b/w ClassNotFoundExp and ClassDefNotFoundError
###################################################################
Loading class using reflection using Class.forName().loadClass-Class not found exception
1)http://stackoverflow.com/questions/1457863/what-is-the-difference-between-noclassdeffounderror-and-classnotfoundexception

####################################################################
Sql Querys : For second last highest salary of employee
Basics of Procedure, Trigger, Cursuor, and Please read joins and implemant it
###################################################################

####################################################################
Diff b/w comparator and comprable interfaces and Also which sort also used for sorting 
###################################################################

##########################################################################
Relection API : Explain in Breif
##########################################################################

####################################################################
Sorting Algo used by Collections.sort();
Uses merge sort or tim sort but Arrays.sort uses quick sort because quicksort is somewhat unstable as compared to merge sort
Quick sort major drawbacks:
It's not stable while it comes to non primitive.
It doesn't guarantee n log n performance.
###################################################################

####################################################################
StringUtil.frequceny(). Method 
###################################################################

####################################################################
Interface and abstract class diff with live example
###################################################################

####################################################################
DesignPattern: Factory,Singleton,Abstract,Facade etc please read all..
###################################################################

####################################################################
Thread and Executor services : Concurrent pkg.
Threa Lock
###################################################################

####################################################################
Thread Syncronization : And Locks
###################################################################

####################################################################
How to detect DeadLock b/w Threads
###################################################################
Using ThreadMXBean Interface that provides various monitoring methods for threads and one of them is findMonitorDeadlockedThreads()
##########################################################################
Iteration of HashMap in diff ways: and know about the method all available in Hash map
##########################################################################

##########################################################################
How HashSet works
##########################################################################
Hashset internally uses hashmap to insert an object but in the add method it returns boolean value true or false
private static final Object PRESENT = new Object();
 public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }
So if object is already present in the map it won't insert else it would insert the object in the hashmap
##########################################################################
What do you mean by Imutability and what are all the imutable class are in java and why are only thay?
http://java-questions.com/ImmutableClass-interview-questions.html
##########################################################################

##########################################################################
Difference between String, StringBuffer, and StringBuilder
##########################################################################

##########################################################################
Diff b/w array and ArrayList ->
##########################################################################

##########################################################################
How to sort Hash Map by value and by Key ->
##########################################################################
Implement comparator which uses compare method
##########################################################################
Diff b/w Thread and Runnable Interface and Thread Executor services
##########################################################################

##########################################################################
Executer framework like semaphore, barrier, latch, thread pool, callable, etc and Thread safety, Explicit locking
##########################################################################

##########################################################################
Overloadding and overriding  or dynamic method dispatch
##########################################################################

##########################################################################
OOPS concepts and fetures : 
##########################################################################

##########################################################################
JAVA ACCESS MODIFIERS: DIFF B/W ACCESS MODIFIERS AND ACCESS SPACIFIERS  (imp jp)
##########################################################################

##########################################################################
JDK1.8 : Lamboda function in java : and also JDK 1.8 fetures
##########################################################################

##########################################################################
JDK1.5, 1.6, 1.7 1.8 fetures Please read it seriously...
##########################################################################

##########################################################################
Serialization and deserivalization and Serialization UID (imp jp)
##########################################################################

##########################################################################
Execption and error diff
##########################################################################

##########################################################################
Equal, HashCode and toString method diff    (V Imp)
##########################################################################

##########################################################################
NIO in bref
##########################################################################

##########################################################################
TreeMap and TreeSet which also use to Sort -> RED and BLACK Tree algo explain
##########################################################################

-----------------------------------------------------------------------------------------------------------------
Advance Java J2EE Question
-----------------------------------------------------------------------------------------------------------------
##########################################################################
Sevlet Life cycle and JSP page life cycle and mulithreading concept for each request it will create new Thread and puting into ThreadPool -> 
##########################################################################

##########################################################################
Request dispature and SendRedirect diff
##########################################################################

##########################################################################
Diff b/w forward and include 
##########################################################################

##########################################################################
Session Mngmt  
##########################################################################

##########################################################################
Filters
##########################################################################

##########################################################################
Listners
##########################################################################

##########################################################################
Sequrity : 
##########################################################################

##########################################################################
JSP implesity objects 
##########################################################################

##########################################################################
JSP Custom tags : 
##########################################################################

##########################################################################
diff Struts 1 and 2 read isa f/w of SAP CRM also 
##########################################################################

##########################################################################
Stuts Flow and Dispatch action and attrubuts of conifg
##########################################################################

##########################################################################
Hibernate Session and Struts and Hibernet integration
##########################################################################

##########################################################################
Hibernate cache mechnizam , first level and second level 
##########################################################################

##########################################################################
Hibernate dirty read and loding lazy and eager and mapping one to one  and annotations
##########################################################################

##########################################################################
Hibernat Sql querys and Critarial API and NATIVE sql and HQL 
##########################################################################

##########################################################################
Spring why come in picture..configration and Annotation configration and java configration
##########################################################################

##########################################################################
Spring modules IOC, DAO , ORM, JPA, MVC, AOP, etc...Valacity
##########################################################################

##########################################################################
Application Context and Bean Factory diff and Spring Listners
##########################################################################

##########################################################################
Spring wiring and scops of request and dependecy injections
##########################################################################

##########################################################################
Spring sequrity and JPA and Spring Trnasation Mangment
##########################################################################

##########################################################################
Hibernat Spring Integration and configration 
##########################################################################

##########################################################################
Spring DAO module and DaoTemplate
##########################################################################

##########################################################################
Spring MVC
##########################################################################

##########################################################################
Spring Execpiton translations
##########################################################################

##########################################################################
Spring and JPA integrationa and also IBatis 
##########################################################################

##########################################################################
Spring and JPA integrationa and also IBatis and IBatic Trnasation Mangement
##########################################################################

##########################################################################
Diff b/w GET and POST methods
##########################################################################

##########################################################################
Diff b/w Rest WebSerivce and SOAP Based Web Services (V IMP) and where to use REST and SOAP Senario
##########################################################################

##########################################################################
Rest/SOAP web Service Example
##########################################################################

##########################################################################
What is Marshaling and Unmarshaling in SOAP Based WebServices
##########################################################################

##########################################################################
JSON Translation and object to json conversion 
##########################################################################

##########################################################################
jurcy jaction and JXB ect tarms...
##########################################################################

##########################################################################
Prefomace Mangemnt Tool and also Sql Query Perfomance Management
##########################################################################

##########################################################################
Prefomace Mangemnt Tool and also Sql Query Perfomance Management
##########################################################################

##########################################################################
How do we handal billions of recode fetched by query in java...
##########################################################################

##########################################################################
Caching the img and frequnetly required data in java
##########################################################################



-----------------------------------------------------------------------------------------------------
DS and ALGO : 

-----------------------------------------------------------------------------------------------------
******************
Searching-----
******************
##########################################################################
Play with an Array : 
##########################################################################

##########################################################################
Binary Search Algo
##########################################################################

##########################################################################
Liner Search Algo
##########################################################################

##########################################################################
Divide and conqure technique
##########################################################################

##########################################################################
Red and Black Tree algo
##########################################################################

******************
Sorting----
******************

##########################################################################
Bubble Sort: 
##########################################################################

##########################################################################
Selection Sort
##########################################################################

##########################################################################
Insertion Sort
##########################################################################

##########################################################################
Quick sort
##########################################################################

##########################################################################
Mearge Sort
##########################################################################

##########################################################################
Heap Sort
##########################################################################







----------------------------------------------------------------------------------------------------------------
Analitical Problems:

50 numbers ( 1 to 50 ) are distributed in random order in an array of size 50.
One number is missing. How to find.
One approach
Sort the array. Numbers are Integer. And in the place of missing there would be default value 0.
We can iterate the array. Can take the zero's place, and the number before and after.
And we know.
----------------------------------------------------------------------------------------------------------------
Why use Inner class.
I would say Inner class is never mandatory or necessary, there is always workaround
But at some places they are convinience like in Map.Entry, Iterator inside List, or
listener in GUI.
The use is to increase encapsulation and hide some implementation details.
Classes like Semaphore use internal objects for locking, etc.
------------------------------------------------------------------------------------
How to implement a Hospital scenario, where doctor is examining patients, and emergency cases,
and informing doctor of emergency cases, scheduling, etc.
We can use a priority Queue
---------------------------------------------------------------------------------------
Why use Atomic Classes?
1. Simple class to perform atomic operations, like AtomicInteger allows integer value to incremented atmically. 
2. Build a complex code with no synchronization, using Atomic Classes
But note Atomic Classes not capable of providing notification's like we have in synchronization: wait/notify.
---------------------------------------------
Synconication Moniting by JVM for Perticuler object refreance->
Each monitor is associated with an object reference. When a thread arrives at the first instruction in a block of code that is under the watchful eye of a monitor,
the thread must obtain a lock on the referenced object.
In Java language terminology, the coordination of multiple threads that must access shared data is called synchronization.
Two opcodes, monitorenter and monitorexit, are used for synchronization blocks within methods.
When monitorenter is encountered by the Java virtual machine, it acquires the lock for the object referred to by objectref
on the stack. If the thread already owns the lock for that object, a count is incremented. Each time monitorexit is executed
for the thread on the object, the count is decremented. When the count reaches zero, the monitor is released.
---------------------------------------------------------------------------

Is Synchronization Enough?
One major purpose of using synchronization is to prevent the race condition that can cause data to be found in intermediate or inconsistent state. But when applying synchronization blocks, we need to take care of few important things - 
1. Threads might be racing prior to the synchronized section of code. 
2. Order in which threads execute the synchronized code is determined by order in which lock is granted.
3. Can we design code so that it is threadsafe with minimal synchronization. 
Atomic Classes is answer to point number 3. 

And next question can be - 

Why use Atomic Classes?
1. Simple class to perform atomic operations, like AtomicInteger allows integer value to incremented atmically. 
2. Build a complex code with no synchronization, using Atomic Classes
But note Atomic Classes not capable of providing notification's like we have in synchronization: wait/notify. 
-------------------------------------------------------------------------------
Difference between Semaphore and Lock ?
1. Lock can have condition and only thread can acquire lock, semaphore has totally different use. Semaphore allows one or more threads to grab permits, and thus only dictates the number of threads working in parallel.
2. Lock is used where we want a piece of code to be executed by only thread. Semaphore is used when we want to limit the number of threads running in parallel and accessing some resources like for example we want only 10 threads to run at any time in parallel no matter if they share any code or data and no matter any condition; or we want to limit the number of connections, etc. 
3. No Condition variables available in semaphore.
4. Locks can be nested like once thread enters synchronized block it can call any other synchronized method on same object. In semaphore multiple acquisitions from same thread results in multiple permits.  
5. Semaphore constructor requires the number: no of permits. Semaphore has methods to return the number of total and free permits. 
6. Semaphore with number of permits equal to 1, is similar to lock. 

Difference between Cyclic Barrier and Countdown Latch ?
1. Important thing in barrier is number(which is increment till it reaches its limit) and in latch is count(which is decremented till it reaches 0). 
2. Any thread can lower the count of latch by calling countDown(), i.e. without waiting, this can't happen in barrier. 
3. Latch can't be reused. 
4. In barrier we can have a BarrierAction, nothing similar is in Latch. 

Why use Thread pool?
For better throughput. 
For eg., if 3 threads with equal priority run in time sliced manner and each one takes 3 secs to complete. Then each one will finish probably in 9 secs. But if we run these three sequentially then one will finish in 3 secs, next in 6 and last in 9 secs. And if threads are running in time sliced manner and number of threads keep on increasing, then each thread will take more time may be 30 secs for each thread if there are 10 threads. Keeping things sequential+parallel i.e., by controlling order of execution and maximum no of threads we can control delay and increase throughput
-----------------------
When are class garbage collected, when are classes unloaded.
The only way that a Class can be unloaded is if the Classloader used is garbage collected. 

How to ensure that instance is never garbage collected.
A singleton kind of pattern. 
There's a static reference to a singleton, so it won't be eligible for garbage collection until the 
classloader is eligible for garbage collection.
In the finalize method store the reference to it
 protected void finalize() throws Throwable {
    MyObjectStore.getInstance().store(this);
    super.finalize();
  }









 


